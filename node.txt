
行为模式
------------------------
1，visitor模式， 访问者模式，即通过将相同的接口类visitor，不同的入参（观察类对象），获得统一的目标信息或者操作。
   我的理解，就是对于一组同领域的不同实体，外部需要获得或者操作这个领域做一组操作时，就可以直接操作观察者。
   好处：
   领域结构更清晰，甚至如果领域内的实体如果是单例时，visitor还可能根据非类入参选择实体实例进行操作。
   visitor提供领域的统一操作，每个实体就不用再提供这些操作了。
   visitor就相当于这样一组对等实体对领域外的接口。

2，catalog模式，通过入参作为键值，选择具体执行的方法。

3，chain模式，在需要根据请求数据符合的规则不同，做不同的处理时（包括处理入参）可以使用chain模式。
   上一个链环执行的输出，作为下一个链环的输入。

4, observer模式，观察者模式，是将实体数据通知给观察者，触发观察者做动作。
   实体具备 绑定观察者、变更数据触发观察者（将自身传给观察者）、解绑观察者；
   观察者在被触发后，执行预定观察到变更的动作。

   实体可以绑定多个观察者，每个观察者被多个实体绑定。

   个人理解，有点像正交操作。一个域的变更负责触发，另一个域对变更做相应的动作。
   再则，换个角度，绑定动作也可以理解为实体提供出订阅接口，visitor 进行订阅；就是订阅发布模式。
5, pub-sub模式，区别订阅发布可以订阅具体关心的事件，在该事件发生时，被订阅者调用订阅者提供的方法。

6, mediator模式，中介者模式，从架构上看，是类似于网关这样的结构。
   具体就是管理复杂的订阅发布和非正交观察者模式（如相互错位观察等）

7, command模式，每个command具备执行和回退两个对外方法，在处理中心还需要维护一个command的清单。
   这个清单可以通过FIFO的方式（清单reserved操作回退），实现一串命令的执行和逆序回退。
   可以用于管理事物操作流的处理。
   可以记录操作，在需要时重新执行一遍（需要进行日志到处理中心构建的生产）

8，memento，备忘录模式，用保存实例以及全部数据（__dict__）快照的方式，可以实现新建实例，并且回到备忘设置的时刻。
  可以和command合并使用，就是实现上面command模式中说的操作回现的功能（处理中心menento模式）









